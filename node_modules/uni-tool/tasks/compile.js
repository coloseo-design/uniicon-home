const gulp = require('gulp');
const path = require('path');
const less = require('less');
const rimraf = require('rimraf');
const postcss = require('postcss');
const babel = require('gulp-babel');
const through2 = require('through2');
const ts = require('gulp-typescript');
const merge = require('merge2');
const NpmImportPlugin = require('less-plugin-npm-import');
const chalk = require('chalk');
const config = require('./config/index');
const command = require('../utils/runCommand');
const { getEslintConfigFilePath } = require('../utils/file');
// configs
const tsCompileConfig = require('./config/gulp/ts.config');
const getBabelConfig = require('./config/babel.config');
const postcssConfig = require('./config/gulp/postcss.config');

const {
  src, dest, parallel, series,
} = gulp;
const tsDefaultReporter = ts.reporter.defaultReporter();

const eslintHandler = (done) => {
  const eslintBin = require.resolve('eslint/bin/eslint');
  const eslintConfig = getEslintConfigFilePath();
  const tsArgs = [eslintBin, '-c', eslintConfig, path.join(config.src, ''), '--ext', '.js,.jsx,.ts,.tsx']; // .concat(lastCmd);
  command('node', tsArgs, (code) => {
    if (code === 0) {
      process.stdout.write(chalk.green('lint tsx files done.\n'));
      done();
    } else {
      throw new Error('eslint 失败');
    }
  });
};

/**
 * compile ts to js
 * @param {boolean} modules false: to es module other: 'auto'
 */
function tsCompile(modules) {
  const tsResult = src(config.tsDir)
    .pipe(through2.obj((file, encoding, next) => {
      if (file.isBuffer()) {
        const content = file.contents.toString(encoding);
        const transformed = `// @ts-nocheck \n ${content}`;
        file.contents = Buffer.from(transformed);
        next(null, file);
      } else {
        next(null, file);
      }
    }))
    .pipe(ts(tsCompileConfig, tsDefaultReporter)); // translate to js
  return merge([
    tsResult.js
      .pipe(babel(getBabelConfig(modules))) // babel
      .pipe(through2.obj(function transformer(file, enc, next) {
        // rename
        Object.assign(file, {
          path: file.path.replace(/\.[jt]sx$/, '.js'),
        });
        this.push(file);
        next();
      }))
      .pipe(dest(path.resolve(modules === false ? config.esDest : config.libDest))),
    tsResult.js.pipe(babel(getBabelConfig(modules))) // babel
      .pipe(through2.obj(function cb(file, encoding, next) {
        this.push(file.clone());
        if (file.path.match(/(\/|\\)styles?(\/|\\)index\.js/)) {
          const content = file.contents.toString(encoding);
          const transform = content
            .replace(/\/style\/?'/g, "/style/css'")
            .replace(/\/style\/?"/g, '/style/css"')
            .replace(/\.less/g, '.css');
          file.contents = Buffer.from(transform);
          file.path = file.path.replace(/index\.js/, 'css.js');
          this.push(file);
          next();
        } else {
          next();
        }
      })).pipe(dest(path.resolve(modules === false ? config.esDest : config.libDest))),
    tsResult.dts.pipe(dest(path.resolve(modules === false ? config.esDest : config.libDest))),
  ]);
}

/**
 *
 * @param {boolean} modules modules true to es dir , or lib dir
 */
function lessCompile(modules) {
  return src(config.lessDir)
    .pipe(through2.obj(function transformer(file, encoding, next) {
      this.push(file.clone());
      if (
        file.path.match(/(\/|\\)styles?(\/|\\)index\.less$/)
        || file.path.match(/(\/|\\)style(\/|\\)v2-compatible-reset\.less$/)
        || file.path.match(/(\/|\\)index\.less$/)
      ) {
        const data = file.contents.toString(encoding);
        const self = this;
        const resolvedLessFile = path.resolve(process.cwd(), file.path);
        less.render(data, {
          paths: [path.dirname(resolvedLessFile)],
          filename: resolvedLessFile,
          plugins: [new NpmImportPlugin({ prefix: '~' })],
          javascriptEnabled: true,
        }).then((result) => {
          const contents = postcss(postcssConfig.plugins).process(result.css, { from: undefined });
          Object.assign(file, {
            contents: Buffer.from(contents.css),
            path: file.path.replace(/\.less$/, '.css'),
          });
          self.push(file);
          next();
        })
          .catch((e) => {
            process.stdout.write(chalk.red(e.message));
          });
      } else {
        next();
      }
    }))
    .pipe(dest(modules === false ? config.esDest : config.libDest));
}

/**
 * 拷贝md文件，md用于生成文档
 * @param {*} modules
 * @returns
 */
function md(modules) {
  return src(config.md)
    .pipe(dest(path.resolve(modules === false ? config.esDest : config.libDest)));
}

/**
 * 拷贝demo源文件，用于生成代码演示
 * @param {*} modules
 * @returns
 */
function cloneDemoFile(modules) {
  return src(config.demo)
    .pipe(dest(path.resolve(modules === false ? config.esDest : config.libDest)));
}

function clean(next) {
  rimraf.sync(config.esDest);
  rimraf.sync(config.libDest);
  next();
}

function compileES() {
  rimraf.sync(config.esDest);
  md(false);
  cloneDemoFile(false);
  return tsCompile(false);
}
function compileLib() {
  rimraf.sync(config.libDest);
  md();
  cloneDemoFile();
  return tsCompile();
}

const es = parallel(() => lessCompile(false), compileES);
const lib = parallel(() => lessCompile(true), compileLib);
const lint = series(eslintHandler);

exports.clean = clean;
exports.es = es;
exports.lib = lib;
exports.less = lessCompile;
exports.lint = lint;
exports.compile = series(lint, es, lib);
